# python-klondike-solver-ai

Курсовий проект з предмету "Штучний інтелект"

Перший алгоритм рішення є евристичним. Кожен можливий хід має номер, який характеризує найкращий хід. Другий алгоритм, званий "алгоритмом розкладу", пробує кілька комбінацій ходів та виконує ту, яка має найбільший пріоритет.

Правило Клондайка

Існують різні стоси: стоси, талон, стоси мастей, стоси зборки. Гра закінчується, коли всі карти 4 мастей будуть складені на стопки 4 мастей зліва вгорі, від туза до короля. Якщо гра зайшла в глухий кут, гравець програв. Під час гри гравець може покласти будь-яку карту на стос масті, якщо ця карта того ж кольору і вище за ту, що лежить на стосі масті. Гравець також може покласти картку на стос масті, якщо ця карта поступається їй і має протилежний колір. Тальйон може покласти в стопку 3 перевернуті карти, тільки та, що лежить зверху, є рухомою. На початку всі стоси мастей і стоси порожні. У стосі 7 мастей знаходяться від однієї до семи карт, карта на вершині - єдина, що лежить вгору.

Структура програми

Програма написана мовою Python 3. Вона складається з 2 класів:
- Game: представляє гру і містить 2 алгоритми.
- Вікно : визначення інтерфейсу користувача Tkinter, що використовується для перегляду ходу гри, хід за ходом.

Гра зберігається у списку списків кортежів. Кожен осередок представляє одну стопку, купу або талон.
Користувач може змінити вміст файлу main.py, щоб використовувати або стратегію викочування або евристичну стратегію. Також можна не відображати вікно, щоб грати якомога більше ігор.

Найскладнішим було визначити, чи гра в глухому куті чи ні. Для цього функція defeat() гри Game перевіряє, чи завжди карта чи набір карт переміщається між двома однаковими стосами. Вона також перевіряє, чи була карта зі стопки складання нещодавно перевернута обличчям вгору, або, для талона, нещодавно розкрита.
Незважаючи на те, що функція виявляє більшість глухих ситуацій, все ще є деякі невиявлені. І тут гра проходить без помилок. Тому в симуляціях я також підраховував ігри, на які йде занадто багато часу.

Евристична стратегія

За цієї стратегії кожен можливий хід має евристичне значення. Це значення є пріоритетом для комп'ютера під час вибору ходу. Значення можна знайти у статті. Можливі ходи: з білда в стек білдів, з білда в стек мастей, з талона в стек білдів, з талона в стек мастей. У моїй версії гри не розглядається лише хід зі стеку мастей у стек білдів, щоб спростити визначення поразки.

Алгоритм гри за цим методом такий:
1. Комп'ютер отримує всі можливі ходи
2. Застосовується критерій першого пріоритету
3. Якщо є кілька ходів із максимальним пріоритетом, ми застосовуємо другий критерій пріоритету.
4. Якщо все ще є кілька ходів із максимальним пріоритетом, комп'ютер вибирає випадковий хід. Інакше він грає хід з найвищим пріоритетом.

За допомогою цієї евристичної стратегії з 1000 партій 150 було виграно, 829 програно і 21 зайняло занадто багато часу, щоб бути прийнятою до уваги.

Ця пропорція близька до пропорції, отриманої командою дослідників.

Стратегія викочування

Стратегія розгортання не може бути дійсно застосована до гри клондайк, тому що вона працює із серією проб та відновлення гри. Але все ж таки цікаво подивитися на результат і відсоток успіху цього алгоритму.

Моя реалізація використовує евристику ходів, яка була використана в першій частині мого проекту. Будемо вважати, що гра перебуває у стані n, комп'ютер виконує такий процес:

1. Знайти ходи: n
2. Виконати один хід: n+1
3. Знайти ходи: n+1
4. Виконати один хід: n+2, і так далі...
5. Якщо кількість ходів досягнуто, збережіть список ходів та поверніться до кроку 1.
6. Якщо всі можливі серії ходів були перевірені, виконайте ту, яка має максимальний пріоритет.

Для 2 ходу, з 1000 партій, 130 було виграно, 851 програно і 19 зайняло занадто багато часу. Для 3 рокіровки, з 1000 ігор, 132 були виграні, 839 були програні і 29 зайняли занадто багато часу. У статті йдеться про те, що відсоток успіху при 2 роулатах наближається до 50%, а при 3 роулатах перевищує 50%.

Команда не деталізує, як комп'ютер вибирає, який хід зробити, тому я застосував евристику першого алгоритму. Кожен перебіг серії оцінюється. Значення серії дорівнює сумі всіх значень кожного ходу серії. Комп'ютер грає серію ходів, яка має максимальне значення. Я також намагався оцінити серію ходів, підраховуючи кількість карток у стопці мастей, але коефіцієнт виграних партій був ще меншим.

Частина коду виконана, евристичний алгоритм працює та дає очікувані результати. Незважаючи на те, що алгоритм працює, функція оцінки серії ходів не працює так, як очікувалося, тому що співвідношення виграних партій здається таким самим, як і при використанні евристичної стратегії. Необхідно створити повнішу функцію оцінки.